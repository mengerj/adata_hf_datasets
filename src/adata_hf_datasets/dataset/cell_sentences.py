import numpy as np
import anndata
import scipy.sparse as sp
import logging
import random

logger = logging.getLogger(__name__)


def create_cell_sentences(
    adata: anndata.AnnData,
    annotation_column: str | None,
    gene_name_column: str,
    cs_length: int,
    include_label_prob: float = 0.7,
) -> anndata.AnnData:
    """
    Generates up to three new columns in adata.obs based on highly variable genes
    and optionally a given cell type annotation (annotation_column).

    The columns created depend on whether annotation_column is provided:
      - "cell_sentence": A space‐separated string of the top cs_length highly variable gene names for that cell (always created).
      - "semantic_true": A semantic sentence generated from the same gene list for that cell (only if annotation_column is provided).
      - "semantic_similar": A semantic sentence taken from a different cell within the same cell type (only if annotation_column is provided).

    The semantic sentence is generated by a helper function
    `generate_semantic_sentence(ranked_genes, cell_type, total_n_cells)`,
    which should be defined externally.

    Parameters
    ----------
    adata : anndata.AnnData
        An AnnData object that has been preprocessed (including HVG selection).
    annotation_column : str | None
        Column in adata.obs that contains the cell type (or similar) annotations.
        If None, semantic sentences will be skipped and only cell_sentence will be generated.
    gene_name_column: str
        Column in adata.var that contains the gene names.
    cs_length : int
        Number of top genes (from the HVG subset) to include in the cell sentence.
    include_label_prob : float, optional
        Probability of including cell type in the semantic sentence (default 0.7).

    Returns
    -------
    anndata.AnnData
        The AnnData object with new columns in adata.obs. Always includes "cell_sentence".
        If annotation_column is provided, also includes "semantic_true" and "semantic_similar".

    Raises
    ------
    ValueError
        If annotation_column is provided but not found in adata.obs.
    """
    # Check if we can create semantic sentences
    create_semantic = annotation_column is not None

    # Verify that the annotation column is present if provided.
    if create_semantic and annotation_column not in adata.obs.columns:
        raise ValueError(
            f"Annotation column '{annotation_column}' not found in adata.obs."
        )

    if not create_semantic:
        logger.warning(
            "annotation_column is None. Will create 'cell_sentence' only. "
            "'semantic_true' and 'semantic_similar' columns will be skipped."
        )
    if "highly_variable" not in adata.var.columns:
        raise ValueError(
            "No highly variable genes found. Please run HVG selection first."
        )
    adata_subset = adata[:, adata.var["highly_variable"]].copy()
    # Determine which expression data to use.
    # ensure_log_norm(adata_subset, var_threshold=0.8) #data was expected to preprocessed with my pipeline..
    X = adata_subset.X

    # If X is sparse, convert to dense.
    if sp.issparse(X):
        X = X.toarray()

    # For this function, we assume the gene names in HVG selection
    # are in adata.var.index (and the HVG selection has already been done).
    if gene_name_column and gene_name_column in adata_subset.var.columns:
        genes = np.array(adata_subset.var[gene_name_column].values)
        logger.info("Using gene names from adata.var[%s].", gene_name_column)
        logger.info("Example gene name: %s", genes[0])
    else:
        genes = np.array(adata_subset.var.index)
        logger.info("Using default gene names from adata.var.index.")
        logger.info("Example gene name: %s", genes[0])

    n_cells = adata.n_obs
    cell_sentences = []  # will hold the raw cell sentence (list of top gene names, as a string)
    semantic_true_list = []  # semantic sentence derived from the same gene list
    # Create a dict mapping from cell type to list of tuples: (cell index, semantic_true)
    semantic_by_type = {}

    # Loop over each cell in the AnnData
    for i in range(n_cells):
        # Get the expression values for the cell.
        expr_vals = X[i, :]
        # Rank genes by descending expression.
        ranks = np.argsort(-expr_vals, kind="stable")
        # Use only the top cs_length genes.
        top_gene_indices = ranks[:cs_length]
        top_genes = genes[top_gene_indices].tolist()
        # Create cell_sentence as a space-separated string.
        cell_sentence = " ".join(top_genes)
        cell_sentences.append(cell_sentence)

        # Only create semantic sentences if annotation column is provided
        if create_semantic:
            # Retrieve cell type from the annotation column.
            cell_type = adata.obs[annotation_column].iloc[i]
            # Generate semantic_true using a helper function (should be defined externally).
            # For example: semantic_sentence = generate_semantic_sentence(top_genes, cell_type, total_n_cells=n_cells)
            try:
                semantic_sentence = generate_semantic_sentence(
                    top_genes,
                    cell_type,
                    total_n_cells=n_cells,
                    include_label_prob=include_label_prob,
                )
            except Exception as e:
                logger.error("Error generating semantic sentence for cell %d: %s", i, e)
                semantic_sentence = (
                    cell_sentence  # fallback; use cell_sentence if error occurs.
                )
            semantic_true_list.append(semantic_sentence)
            # Store in the dictionary for later pairing.
            if cell_type not in semantic_by_type:
                semantic_by_type[cell_type] = []
            semantic_by_type[cell_type].append((i, semantic_sentence))

    # Store the generated sentences in adata.obs.
    adata.obs["cell_sentence"] = cell_sentences

    if create_semantic:
        adata.obs["semantic_true"] = semantic_true_list

        # Now, create "semantic_similar" by pairing cells with the same cell type.
        # We'll choose, for each cell, a different cell in the same type.
        semantic_similar = [None] * n_cells

        for cell_type, entries in semantic_by_type.items():
            # Sort entries by cell index to preserve the order from the original data.
            entries.sort(key=lambda x: x[0])
            indices = [entry[0] for entry in entries]
            sems = [entry[1] for entry in entries]
            n_group = len(sems)
            for j, idx in enumerate(indices):
                # If there's more than one cell in the group, choose the next cell's semantic as "similar".
                # Otherwise, default to the cell's own semantic.
                if n_group == 1:
                    semantic_similar[idx] = sems[0]
                else:
                    # For example, choose the next cell in the sorted order, wrapping around if needed.
                    semantic_similar[idx] = sems[(j + 1) % n_group]

        adata.obs["semantic_similar"] = semantic_similar

        logger.info(
            "Created columns: 'cell_sentence', 'semantic_true', and 'semantic_similar'."
        )
    else:
        logger.info(
            "Created column: 'cell_sentence'. Semantic columns skipped due to missing annotation_column."
        )

    return adata


def generate_semantic_sentence(
    gene_list, cell_type=None, total_n_cells=100000, include_label_prob=0.7
):
    """
    Generate a sentence from a list of genes and optionally a cell type.
    Args:
        gene_list (list): list of gene symbols
        cell_type (str or None): cell type label
        include_label_prob (float): probability of including cell type in the sentence
    Returns:
        str: A natural language sentence describing the cell
    """
    gene_str = ", ".join(gene_list)
    templates_with_label_full = [
        f"A cell that expresses the following genes: {gene_str} is likely a {cell_type} cell.",
        f"This cell shows high expression of {gene_str}, suggesting it is a {cell_type}.",
        f"Based on the expression of {gene_str}, this appears to be a {cell_type} cell.",
        f"The genes {gene_str} are expressed in this cell, which is classified as a {cell_type}.",
        f"{cell_type} cells typically express genes such as: {gene_str}.",
        f"The combination of {gene_str} is characteristic for {cell_type} cells.",
        f"This transcriptomic profile — with genes like {gene_str} — resembles that of a {cell_type}.",
        f"A typical {cell_type} cell expresses the genes: {gene_str}.",
        f"A {cell_type} signature includes: {gene_str}.",
        f"The expression pattern of {gene_str} strongly indicates a {cell_type} cell.",
        f"{gene_str} are commonly found in {cell_type} cells.",
        f"Gene expression matches that of {cell_type} cells, including: {gene_str}.",
        f"Cells expressing {gene_str} often belong to the {cell_type} lineage.",
        f"The gene markers {gene_str} suggest this cell is a {cell_type}.",
        f"These expression features — {gene_str} — are typical of a {cell_type} identity.",
        f"Observed genes ({gene_str}) are indicative of {cell_type} cell function.",
        f"With genes like {gene_str} active, this cell is identified as a {cell_type}.",
        f"Expressing {gene_str}, this cell is consistent with {cell_type} identity.",
        f"The cell’s transcriptome points to a {cell_type} lineage, with key genes like {gene_str}.",
        f"This cell likely originates from the {cell_type} family, based on expression of {gene_str}.",
        f"{cell_type} cells are known to express: {gene_str}.",
        f"The expression of {gene_str} aligns with a {cell_type} identity.",
        f"The transcriptome suggests a {cell_type} type, with expression of {gene_str}.",
        f"Given {gene_str}, this cell can be classified as a {cell_type}.",
        f"This profile resembles {cell_type} cells, based on genes like {gene_str}.",
        f"The pattern {gene_str} is indicative of {cell_type} differentiation.",
        f"Expression of {gene_str} suggests {cell_type} lineage commitment.",
        f"Typical {cell_type} markers such as {gene_str} are present in this cell.",
        f"This cell fits the molecular signature of {cell_type}, expressing {gene_str}.",
        f"The transcriptomic signal ({gene_str}) matches a {cell_type} phenotype.",
        f"The active genes {gene_str} align with a {cell_type} signature.",
        f"Presence of {gene_str} supports classification as {cell_type}.",
        f"{gene_str} expression pattern defines this as a {cell_type} cell.",
        f"Consistent with {cell_type} function, genes like {gene_str} are expressed.",
        f"This expression fingerprint ({gene_str}) marks a {cell_type} cell.",
        f"{gene_str} expression places this cell in the {cell_type} category.",
        f"According to gene expression ({gene_str}), this is a {cell_type}.",
        f"A transcriptome with {gene_str} points toward {cell_type} identity.",
        f"{gene_str} reflect the unique expression profile of {cell_type} cells.",
        f"Genes like {gene_str} are hallmarks of {cell_type} cells.",
    ]

    templates_without_label_full = [
        f"A cell that expresses: {gene_str}.",
        f"This cell expresses the genes: {gene_str}.",
        f"Highly expressed genes: {gene_str}.",
        f"Expression profile includes: {gene_str}.",
        f"{gene_str} are the top expressed genes in this cell.",
        f"Transcriptomic features: {gene_str}.",
        f"Detected gene expression: {gene_str}.",
        f"This cell shows significant expression of: {gene_str}.",
        f"Key genes active in this cell: {gene_str}.",
        f"The expression pattern includes: {gene_str}.",
        f"Observed top genes: {gene_str}.",
        f"The cell displays expression of: {gene_str}.",
        f"Gene ranking includes: {gene_str}.",
        f"High-ranking genes: {gene_str}.",
        f"Based on transcriptomics, {gene_str} are key features.",
        f"Top genes from expression profile: {gene_str}.",
        f"Leading genes expressed: {gene_str}.",
        f"This cell is characterized by expression of: {gene_str}.",
        f"{gene_str} define the expression landscape of this cell.",
        f"The active transcriptional program includes: {gene_str}.",
    ]

    # Scale template usage with dataset size
    if total_n_cells < 10000:
        max_with = 10
        max_without = 5
    elif total_n_cells < 100000:
        max_with = 20
        max_without = 10
    else:
        max_with = 40
        max_without = 20

    templates_with_label = random.sample(templates_with_label_full, max_with)
    templates_without_label = random.sample(templates_without_label_full, max_without)

    if cell_type and random.random() < include_label_prob:
        return random.choice(templates_with_label)
    else:
        return random.choice(templates_without_label)
